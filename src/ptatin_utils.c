/*@ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 **
 **    Copyright (c) 2012, 
 **        Dave A. May [dave.may@erdw.ethz.ch]
 **        Geophysical Fluid Dynamics, 
 **        Department of Earth Sciences,
 **        ETH ZÃ¼rich,
 **        Sonneggstrasse 5,
 **        CH-8092 Zurich,
 **        Switzerland
 **
 **    Project:       pTatin3d
 **    Filename:      ptatin_utils.c
 **
 **
 **    pTatin3d is free software: you can redistribute it and/or modify
 **    it under the terms of the GNU General Public License as published by
 **    the Free Software Foundation, either version 3 of the License, or
 **    (at your option) any later version.
 **
 **    pTatin3d is distributed in the hope that it will be useful,
 **    but WITHOUT ANY WARRANTY; without even the implied warranty of
 **    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 **    GNU General Public License for more details.
 **
 **    You should have received a copy of the GNU General Public License
 **    along with pTatin3d.  If not, see <http://www.gnu.org/licenses/>.
 **
 **
 **    $Id$
 **
 ** ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~@*/

#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include <pwd.h>


#include "petsc.h"
#include "ptatin_utils.h"

#undef __FUNCT__
#define __FUNCT__ "pTatinCreateDirectory"
PetscErrorCode pTatinCreateDirectory(const char dirname[])
{
	mode_t mode;
	PetscMPIInt rank;
	int num,error_number;
	
	PetscFunctionBegin;
	MPI_Comm_rank(PETSC_COMM_WORLD,&rank);
	
	/* Generate a new directory on proc 0 */
	if (rank == 0) {
		num = mkdir(dirname,S_IRWXU);
		error_number = errno;
	}
	MPI_Bcast(&num,1,MPI_INT,0,PETSC_COMM_WORLD);
	MPI_Bcast(&error_number,1,MPI_INT,0,PETSC_COMM_WORLD);
	
	if (error_number == EEXIST) {
		PetscPrintf(PETSC_COMM_WORLD,"Writing output to existing directory %s \n",dirname);
	} else if (error_number == EACCES) {
		SETERRQ(PETSC_COMM_WORLD,PETSC_ERR_USER,"Write permission is denied for the parent directory in which the new directory is to be added");
	} else if (error_number == EMLINK) {
		SETERRQ(PETSC_COMM_WORLD,PETSC_ERR_USER,"The parent directory has too many links (entries)");
	} else if (error_number == ENOSPC) {
		SETERRQ(PETSC_COMM_WORLD,PETSC_ERR_USER,"The file system doesn't have enough room to create the new directory");
	} else if (error_number == ENOSPC) {
		SETERRQ(PETSC_COMM_WORLD,PETSC_ERR_USER,"The parent directory of the directory being created is on a read-only file system and cannot be modified");
	} else {
		PetscPrintf(PETSC_COMM_WORLD,"Created output directory %s \n",dirname);
	}
	
	MPI_Barrier(PETSC_COMM_WORLD);
	PetscFunctionReturn(0);
}

/* don't write out options this way, they cannot be loaded from file */
/*
 ierr = PetscOptionsGetAll(&copts);CHKERRQ(ierr);
 PetscPrintf(PETSC_COMM_WORLD,"All opts: %s \n", copts);
 ierr = PetscOptionsInsertFile(PETSC_COMM_WORLD,"test.opts",PETSC_FALSE);CHKERRQ(ierr);
 */
#undef __FUNCT__
#define __FUNCT__ "pTatinWriteOptionsFile"
PetscErrorCode pTatinWriteOptionsFile(const char filename[])
{
	PetscViewer viewer;
	char username[PETSC_MAX_PATH_LEN];
	char date[PETSC_MAX_PATH_LEN];
	char machine[PETSC_MAX_PATH_LEN];
	char prgname[PETSC_MAX_PATH_LEN];
	PetscErrorCode ierr;
	
	if (!filename) {
		ierr = PetscViewerASCIIOpen(PETSC_COMM_WORLD,"ptatin.options",&viewer);CHKERRQ(ierr);
	} else {
		ierr = PetscViewerASCIIOpen(PETSC_COMM_WORLD,filename,&viewer);CHKERRQ(ierr);
	}
	
	/* write header into options file */
	ierr = PetscGetUserName(username,PETSC_MAX_PATH_LEN-1);CHKERRQ(ierr);
	ierr = PetscGetDate(date,PETSC_MAX_PATH_LEN-1);CHKERRQ(ierr);
	ierr = PetscGetHostName(machine,PETSC_MAX_PATH_LEN-1);CHKERRQ(ierr);
	ierr = PetscGetProgramName(prgname,PETSC_MAX_PATH_LEN-1);CHKERRQ(ierr);
	ierr = PetscViewerASCIIPrintf(viewer,"## =============================================================== \n");CHKERRQ(ierr);
	ierr = PetscViewerASCIIPrintf(viewer,"##\n");CHKERRQ(ierr);
	ierr = PetscViewerASCIIPrintf(viewer,"##   pTatin options file\n");CHKERRQ(ierr);
	ierr = PetscViewerASCIIPrintf(viewer,"##\n");CHKERRQ(ierr);
	ierr = PetscViewerASCIIPrintf(viewer,"##   Generated by user: %s\n",username);CHKERRQ(ierr);
	ierr = PetscViewerASCIIPrintf(viewer,"##   Date             : %s\n",date);CHKERRQ(ierr);
	ierr = PetscViewerASCIIPrintf(viewer,"##   Machine          : %s\n",machine);CHKERRQ(ierr);
	ierr = PetscViewerASCIIPrintf(viewer,"##   Using driver     : %s\n",prgname);CHKERRQ(ierr);
	ierr = PetscViewerASCIIPrintf(viewer,"##\n");CHKERRQ(ierr);
	ierr = PetscViewerASCIIPrintf(viewer,"## =============================================================== \n");CHKERRQ(ierr);
	
	/* write options */
	ierr = PetscOptionsView(viewer);CHKERRQ(ierr);
	
	ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
	
	PetscFunctionReturn(0);
}

void pTatinGenerateFormattedTimestamp(char date_time[])
{
	time_t      currTime;
	struct tm*  timeInfo;
	int         adjustedYear;
	int         adjustedMonth;
	char        user_name[200];
	
	currTime = time( NULL );
	timeInfo = localtime( &currTime );
	/* See man localtime() for why to adjust these */
	adjustedYear = 1900 + timeInfo->tm_year;
	adjustedMonth = 1 + timeInfo->tm_mon;
	/* Format; MM(string) DD HH:MM:SS YYYY */	
	/*
	 printf( "%s %.2d %.2d:%.2d:%.2d %.4d \n",  
	 months[adjustedMonth], timeInfo->tm_mday,
	 timeInfo->tm_hour, timeInfo->tm_min, timeInfo->tm_sec, adjustedYear );
	 */
	sprintf( date_time, "%.4d.%.2d.%.2d_%.2d:%.2d:%.2d",  
					adjustedYear, adjustedMonth, timeInfo->tm_mday,
					timeInfo->tm_hour, timeInfo->tm_min, timeInfo->tm_sec );
}

void FileExists(const char fname[],int *exists)
{
	FILE *file = NULL;
	
	file = fopen(fname, "r");
	
	if (file) {
		fclose(file);
		*exists = 1;
	} else {
		*exists = 0;
	}
	MPI_Barrier(PETSC_COMM_WORLD);
}

void FileExistsRank(MPI_Comm comm,const char fname[],int *exists)
{
	int   rank,size;
	char  fname_rank[1024];
	FILE  *file = NULL;

	
	MPI_Comm_size(comm,&size);
	MPI_Comm_rank(comm,&rank);
	if (size == 1) {
		sprintf(fname_rank,"%s",fname);
	} else {
		sprintf(fname_rank,"%s_p%.5d",fname,rank);
	}
	
	file = fopen(fname_rank, "r");
	
	if (file) {
		fclose(file);
		*exists = 1;
	} else {
		*exists = 0;
	}
	MPI_Barrier(PETSC_COMM_WORLD);
}

int StringEmpty(const char string[])
{
	if (string) { /* AND (or &&) */
    if (string[0] == '\0') {
			return 1;
    }
	} else {
		return 1;
	}
	return 0;
}

void ptatin_RandomSetSeed(unsigned seed)
{
	srand(seed);
}
void ptatin_RandomSetSeedRank(MPI_Comm comm)
{
	int rank,ierr;
	
	MPI_Comm_rank(comm,&rank);
	srand((unsigned)rank);
}

double ptatin_RandomGetDouble(double min,double max)
{
	double r,rr;
	
	r = rand()/((double)(RAND_MAX));
	rr =  min + (max - min) * r;
	return rr;
}

int ptatin_RandomGetInt(int min,int max)
{
	double r,rr;
	int ri;
	
	r = rand()/((double)(RAND_MAX));
	rr =  ((double)min) + ((double)(max - min)) * r;
	ri = (int)rr;
	return ri;
}




